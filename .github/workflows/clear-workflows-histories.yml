name: Delete workflows Actions History

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "List runs without deleting"
        required: false
        default: "false"
  schedule:
    - cron: "0 3 */2 * *" # every 2 days at 03:00 UTC

permissions:
  actions: write
  contents: read

concurrency:
  group: purge-workflow-history
  cancel-in-progress: false

jobs:
  purge:
    name: Delete all completed workflow runs
    runs-on: ubuntu-latest
    steps:
      - name: Purge completed runs (streaming + backoff)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const currentRunId = context.runId;
            const dryRun = (core.getInput('dry_run') || 'false').toLowerCase() === 'true';

            const sleep = (ms) => new Promise(res => setTimeout(res, ms));

            async function deleteWithRetry(run) {
              const maxAttempts = 6;
              let delay = 1000; // start 1s, exponential backoff
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                  if (dryRun) {
                    core.info(`[dry-run] would delete run ${run.id} (${run.name} #${run.run_number}) created ${run.created_at}`);
                    return true;
                  }
                  await github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id });
                  core.info(`deleted run ${run.id} (${run.name} #${run.run_number})`);
                  return true;
                } catch (err) {
                  const status = err.status || 0;
                  const msg = err.message || String(err);
                  // Retry only on throttling or transient server errors
                  const retriable = status === 429 || status === 502 || status === 503 || status === 504 ||
                                    (status === 403 && /rate|secondary rate/i.test(msg));
                  if (!retriable || attempt === maxAttempts) {
                    core.warning(`failed to delete run ${run.id} (${run.name} #${run.run_number}) [status=${status}]: ${msg}`);
                    return false;
                  }
                  core.info(`rate-limited; backing off ${delay}ms (attempt ${attempt}/${maxAttempts})`);
                  await sleep(delay);
                  delay = Math.min(delay * 2, 30000);
                }
              }
              return false;
            }

            let deleted = 0, skipped = 0, failed = 0;

            // Stream pages to avoid loading everything into memory
            const iterator = github.paginate.iterator(
              github.rest.actions.listWorkflowRunsForRepo,
              {
                owner, repo,
                per_page: 100,
                status: 'completed' // only completed runs are eligible for deletion
              }
            );

            for await (const { data: runs } of iterator) {
              for (const run of runs) {
                // Extra safety: never delete this job's run; skip any non-completed just in case
                if (run.id === currentRunId || run.status !== 'completed') {
                  skipped++;
                  continue;
                }
                const ok = await deleteWithRetry(run);
                ok ? deleted++ : failed++;
              }
            }

            const summary = `Deleted=${deleted}, Skipped=${skipped}, Failed=${failed}, DryRun=${dryRun}`;
            if (failed > 0) core.warning(summary); else core.notice(summary);